package party

import (
	"fmt"
	"math/rand"
	"strconv"
	"sync"
	"time"

	"github.com/DyCAPSTeam/DyCAPS/internal/commitment"
	"go.dedis.ch/kyber/v3/pairing"

	"github.com/Nik-U/pbc"
	"github.com/ncw/gmp"
	"go.dedis.ch/kyber/v3/share"
	"go.dedis.ch/kyber/v3/sign/tbls"
	"google.golang.org/protobuf/proto"

	"github.com/DyCAPSTeam/DyCAPS/internal/conv"
	"github.com/DyCAPSTeam/DyCAPS/internal/ecparam"
	"github.com/DyCAPSTeam/DyCAPS/internal/interpolation"
	"github.com/DyCAPSTeam/DyCAPS/internal/polyring"
	"github.com/DyCAPSTeam/DyCAPS/pkg/protobuf"
)

//Party is an interface of committee members
type Party interface {
	send(m *protobuf.Message, des uint32) error
	broadcast(m *protobuf.Message) error
	getMessageWithType(messageType string) (*protobuf.Message, error)
}

type PiContent struct {
	j uint32
	//In DyCAPS.Share, CBj refers to commitment to B(x,j) generated by dealer.
	//In DyCAPS.Handoff, CBj refers to commitment to Q_i(x,j) generated by Party i
	CBj *pbc.Element
	CZj *pbc.Element //Z_j(x)=R_j(x)-R_j(0)
	WZ0 *pbc.Element //witness of Z_j(0)=0
	gFj *pbc.Element //g^F(j), F(j) is of t degree
}

type Pi struct {
	Gs         *pbc.Element // g^s
	PiContents []PiContent
}

//HonestParty is a struct of honest committee members
//TODO: add epoch number into this struct
type HonestParty struct {
	N            uint32   // committee size
	F            uint32   // number of corrupted parties
	PID          uint32   // id of this party
	ipList       []string // ip list of the current committee
	portList     []string // port list of the current committee
	sendChannels []chan *protobuf.Message

	ipListNext         []string // ip list of the new committee
	portListNext       []string // port list of the new committee
	sendToNextChannels []chan *protobuf.Message

	dispatchChannels *sync.Map

	SigPK *share.PubPoly  //tss pk
	SigSK *share.PriShare //tss sk

	Proof *Pi //pi

	fullShare    polyring.Polynomial // B(i,y), i=p.PID+1
	reducedShare polyring.Polynomial // B(x,j), j=p.PID+1

	witness        []*pbc.Element //witness[j] = w_B(i,*), each party has at least 2t+1 witness
	witnessIndexes []*gmp.Int     //witnessIndexes[j] means the * value of witness[j]
}

// SRecElement is the set of elements for recover
type SRecElement struct {
	j uint32
	v *gmp.Int
}

// SSigElement is the set of signatures
type SSigElement struct {
	j   uint32
	Sig []byte
}

// SComElement is the set of commitments
type SComElement struct {
	j  uint32
	CB *pbc.Element
}

// SBElement is the set of elements for full shares
type SBElement struct {
	j  uint32
	CB *pbc.Element
	v  *gmp.Int
	w  *pbc.Element
}

var SysSuite = pairing.NewSuiteBn256()
var KZG = new(commitment.DLPolyCommit)
var mutexKZG sync.Mutex

//NewHonestParty returns a new honest party object
func NewHonestParty(N uint32, F uint32, pid uint32, ipList []string, portList []string, ipListNext []string, portListNext []string, sigPK *share.PubPoly, sigSK *share.PriShare) *HonestParty {
	piInit := new(Pi)
	piInit.Init(F)
	witness := make([]*pbc.Element, 2*F+2)
	witnessIndexes := make([]*gmp.Int, 2*F+2)
	for i := 0; uint32(i) < 2*F+2; i++ {
		witness[i] = KZG.NewG1()
		witnessIndexes[i] = gmp.NewInt(0)
	}
	p := HonestParty{
		N:                  N,
		F:                  F,
		PID:                pid,
		ipList:             ipList,
		portList:           portList,
		ipListNext:         ipListNext,
		portListNext:       portListNext,
		sendChannels:       make([]chan *protobuf.Message, N),
		sendToNextChannels: make([]chan *protobuf.Message, N),

		SigPK: sigPK,
		SigSK: sigSK,

		Proof: piInit,

		fullShare:      polyring.NewEmpty(),
		reducedShare:   polyring.NewEmpty(),
		witness:        witness,
		witnessIndexes: witnessIndexes,
	}
	return &p
}

func (p *HonestParty) ProactivizeAndShareDist(ID []byte) {
	ecparamN := ecparam.PBC256.Ngmp

	var flgCom = make([]uint32, p.N+1)
	var flgRec = make([]uint32, p.N+1)
	for i := uint32(0); i <= p.N; i++ {
		flgCom[i] = 0
		flgRec[i] = 0
	}
	var piI = make([]PiContent, 0)

	var Z = make([]polyring.Polynomial, p.N+1) //Z_ij(x)=Q_i(x,j)-F_j(j), which means Z_ij(0)=0
	var Fj = gmp.NewInt(0)                     //F_i(j)
	var gFj = KZG.NewG1()                      //g^F_i(j)
	var CQ = make([][]*pbc.Element, p.N+1)
	var CZ = make([]*pbc.Element, p.N+1)
	var wZ = make([]*pbc.Element, p.N+1)
	var vF = make([][][]*gmp.Int, p.N+1)
	var wF = make([][][]*pbc.Element, p.N+1)

	for i := uint32(0); i <= p.N; i++ {
		vF[i] = make([][]*gmp.Int, p.N+1)
		wF[i] = make([][]*pbc.Element, p.N+1)

		for j := uint32(0); j <= p.N; j++ {
			vF[i][j] = make([]*gmp.Int, p.N+1)
			wF[i][j] = make([]*pbc.Element, p.N+1)

			for k := uint32(0); k <= p.N; k++ {
				vF[i][j][k] = gmp.NewInt(0)
				wF[i][j][k] = KZG.NewG1()
			}
		}
	}

	for j := uint32(0); j <= p.N; j++ {
		Z[j] = polyring.NewEmpty()
		CQ[j] = make([]*pbc.Element, p.N+1)

		for k := uint32(0); k <= p.N; k++ {
			CQ[j][k] = KZG.NewG1()
		}
		CZ[j] = KZG.NewG1()
		wZ[j] = KZG.NewG1()
	}

	//TODO: use crypto/rand instead
	var rnd = rand.New(rand.NewSource(time.Now().UTC().UnixNano()))
	var polyF, _ = polyring.NewRand(int(2*p.F), rnd, ecparamN)
	polyF.SetCoefficientBig(0, gmp.NewInt(0))

	//Q keeps the polynomials generates by all parties.
	//Q[p.PID+1][] denotes the 2t+1 polynomials generated by itself.
	//i and j in Q[i][j] start from 1
	var Q = make([][]polyring.Polynomial, p.N+1)
	for j := uint32(0); j <= p.N; j++ {
		Q[j] = make([]polyring.Polynomial, p.N+1)

		//FIXME: this N should be 2t+1?
		for k := uint32(0); k <= p.N; k++ {
			Q[j][k] = polyring.NewEmpty()
		}
	}

	//generate the 2t+1 t-degree random polynomials
	for j := uint32(1); j <= 2*p.F+1; j++ {
		polyF.EvalMod(gmp.NewInt(int64(j)), ecparamN, Fj)
		rnd = rand.New(rand.NewSource(time.Now().UTC().UnixNano()))
		Q[p.PID+1][j], _ = polyring.NewRand(int(p.F), rnd, ecparamN)
		Q[p.PID+1][j].SetCoefficientBig(0, Fj) // Q_i(0,j)=F_i(j)
	}

	//Commit
	for j := uint32(1); j <= 2*p.F+1; j++ {
		var tmpPoly = polyring.NewEmpty()
		tmpPoly.SetCoefficientBig(0, Fj)
		KZG.Commit(gFj, tmpPoly)

		Z[j].Sub(Q[p.PID+1][j], tmpPoly) //Z_ij(x)=Q_i(x,j)-F_j(j), which means Z_ij(0)=0
		KZG.Commit(CQ[p.PID+1][j], Q[p.PID+1][j])
		KZG.Commit(CZ[j], Z[j])
		KZG.CreateWitness(wZ[j], Z[j], gmp.NewInt(0))

		piI = append(piI, PiContent{
			j,
			KZG.NewG1().Set(CQ[p.PID+1][j]),
			KZG.NewG1().Set(CZ[j]),
			KZG.NewG1().Set(wZ[j]),
			KZG.NewG1().Set(gFj)})
		// piI[j-1].WZ0.Set(wZ[j])
		// piI[j-1].CZj.Set(CZ[j])
		// piI[j-1].CBj.Set(CQ[p.PID+1][j])
		// piI[j-1].gFj.Set(gFj)
	}

	var CommitMessage = new(protobuf.Commit)
	CommitMessage.Sig = make([]*protobuf.PiContent, 2*p.F+1)
	for j := uint32(0); j < 2*p.F+1; j++ {
		CommitMessage.Sig[j] = new(protobuf.PiContent)
		CommitMessage.Sig[j].J = piI[j].j
		CommitMessage.Sig[j].WZ_0 = piI[j].WZ0.CompressedBytes()
		CommitMessage.Sig[j].CBJ = piI[j].CBj.CompressedBytes()
		CommitMessage.Sig[j].CZJ = piI[j].CZj.CompressedBytes()
		CommitMessage.Sig[j].G_Fj = piI[j].gFj.CompressedBytes()
	}
	//fmt.Println("Party ", p.PID, "Commit Message is", Commit_Message)
	CommitMessageData, _ := proto.Marshal(CommitMessage)
	p.RBCSend(&protobuf.Message{Type: "Commit", Sender: p.PID, Id: ID, Data: CommitMessageData}, []byte(string(ID)+strconv.FormatUint(uint64(p.PID+1), 10)))

	//Verify
	go func() {
		for j := uint32(1); j <= p.N; j++ {
			go func(j uint32) {
				m := p.RBCReceive([]byte(string(ID) + strconv.FormatUint(uint64(j), 10)))
				fmt.Println("Party", p.PID, "receive RBC message from", m.Sender, "in ShareDist Phase,the ID is", string(ID))
				var Received_Data protobuf.Commit
				proto.Unmarshal(m.Data, &Received_Data)
				// var Verify_Flag = KZG.NewG1()
				// Verify_Flag = Verify_Flag.Set1()
				lambda := make([]*gmp.Int, 2*p.F+1)
				knownIndexes := make([]*gmp.Int, 2*p.F+1)
				for k := 0; uint32(k) < 2*p.F+1; k++ {
					lambda[k] = gmp.NewInt(int64(k + 1))
				}
				for k := 0; uint32(k) < 2*p.F+1; k++ {
					knownIndexes[k] = gmp.NewInt(int64(k + 1))
				}
				polyring.GetLagrangeCoefficients(2*p.F, knownIndexes, ecparamN, gmp.NewInt(0), lambda)
				var tmp = KZG.NewG1()
				var tmp2 = KZG.NewG1()
				var tmp3 = KZG.NewG1()
				var copyTmp3 = KZG.NewG1()
				var tmp4 = KZG.NewG1()
				tmp3.Set1()
				tmp4.Set1()
				for k := uint32(0); k < 2*p.F+1; k++ {
					tmp.SetCompressedBytes(Received_Data.Sig[k].G_Fj) // change tmp = tmp.SetCompressedBytes(Received_Data.Sig[k].G_Fj)
					tmp2.PowBig(tmp, conv.GmpInt2BigInt(lambda[k]))
					copyTmp3.Set(tmp3)
					tmp3.Mul(copyTmp3, tmp2)
				}
				if !tmp3.Equals(tmp4) {
					return //possible bug
				}

				var revertFlag = false
				for k := 0; uint32(k) < 2*p.F+1; k++ {
					CRk := KZG.NewG1()
					CZk := KZG.NewG1()
					wZk := KZG.NewG1()
					Gjk := KZG.NewG1()
					CRk.SetCompressedBytes(Received_Data.Sig[k].CBJ)
					CQ[m.Sender+1][k+1].Set(CRk) //added by ch
					CZk.SetCompressedBytes(Received_Data.Sig[k].CZJ)
					wZk.SetCompressedBytes(Received_Data.Sig[k].WZ_0)
					Gjk.SetCompressedBytes(Received_Data.Sig[k].G_Fj)
					mulRes := KZG.NewG1()
					mulRes.Mul(CZk, Gjk)
					mutexKZG.Lock()
					if !KZG.VerifyEval(CZk, gmp.NewInt(0), gmp.NewInt(0), wZk) || !CRk.Equals(mulRes) {
						mutexKZG.Unlock()
						revertFlag = true
						break
					} else {
						mutexKZG.Unlock()
					}

				}
				if revertFlag {
					return //possible bug
				}

				for l := 2*p.F + 2; l <= p.N; l++ {
					polyring.GetLagrangeCoefficients(2*p.F, knownIndexes, ecparamN, gmp.NewInt(int64(l)), lambda)
					CQ[m.Sender+1][l].Set1()
					powRes := KZG.NewG1()
					copyCR := KZG.NewG1()
					for k := 1; uint32(k) <= 2*p.F+1; k++ {
						powRes.PowBig(CQ[m.Sender+1][k], conv.GmpInt2BigInt(lambda[k-1]))
						copyCR.Set(CQ[m.Sender+1][l])
						CQ[m.Sender+1][l].Mul(copyCR, powRes)
					}
				}
				flgCom[m.Sender+1] = 1 //ch change j to m.Sender.
			}(j)
		}

	}()

	//Reshare
	var wf = make([][]*pbc.Element, p.N+1)
	for k := uint32(1); k <= p.N; k++ {
		var reshareMessage protobuf.Reshare
		reshareMessage.Wk = make([][]byte, 2*p.F+1) //added
		reshareMessage.Fk = make([][]byte, 2*p.F+1) //added
		wf[k] = make([]*pbc.Element, p.N+1)

		for j := uint32(1); j <= 2*p.F+1; j++ {

			wf[k][j] = KZG.NewG1()
			KZG.CreateWitness(wf[k][j], Q[p.PID+1][j], gmp.NewInt(int64(k))) // changed.
			var Fkj = gmp.NewInt(0)

			//Denote Ri,j(k) as [Fi(j)]k
			Q[p.PID+1][j].EvalMod(gmp.NewInt(int64(k)), ecparamN, Fkj)

			vF[p.PID+1][j][k].Set(Fkj)
			wF[p.PID+1][j][k].Set(wf[k][j])
			reshareMessage.Wk[j-1] = wf[k][j].CompressedBytes()
			reshareMessage.Fk[j-1] = Fkj.Bytes()
		}

		reshareData, _ := proto.Marshal(&reshareMessage)
		p.Send(&protobuf.Message{Type: "Reshare", Id: ID, Sender: p.PID, Data: reshareData}, uint32(k-1))
		fmt.Println("Party ", p.PID, "send Reshare message to", k-1, "the content is", reshareMessage)
	}

	//Vote
	var ReshareDataMap = make(map[uint32]protobuf.Reshare)
	var mutexReshareDataMap sync.Mutex
	var Sig = make(map[uint32]map[uint32][]byte)
	for i := uint32(1); i <= p.N; i++ {
		Sig[i] = make(map[uint32][]byte)
	}

	go func() {
		for {
			m := <-p.GetMessage("Reshare", ID) // this ID is not correct //ch thinks it is correct
			var ReceivedReshareData protobuf.Reshare
			proto.Unmarshal(m.Data, &ReceivedReshareData)

			//fmt.Println("Party", p.PID, "receive Reshare message from", m.Sender, "the content is", Received_Reshare_Data.Wk)
			mutexReshareDataMap.Lock()
			_, ok := ReshareDataMap[m.Sender+1]
			if !ok {
				ReshareDataMap[m.Sender+1] = ReceivedReshareData
			}
			mutexReshareDataMap.Unlock()
		}
	}()
	go func() {
		for { //TODO: change busy waiting to block waiting later.
			mutexReshareDataMap.Lock()
			for j := uint32(1); j <= p.N; j++ {
				_, ok := ReshareDataMap[j]
				if ok == true && flgCom[j] == 1 {
					//if p.PID == uint32(5) && j == 7 {
					//	fmt.Println("enter 2")
					//}
					var wjk *pbc.Element
					var vjki *gmp.Int
					vjki = gmp.NewInt(0)
					wjk = KZG.NewG1()
					currentData := ReshareDataMap[j]
					var VoteRevertFlag = false
					/*
						if p.PID == uint32(3) {
							fmt.Println("In vote phase,the C_Rist is:")
							for k := 1; uint32(k) <= p.N; k++ {
								fmt.Println("CQ", j, k, "=", CQ[j][k].String())
							}
						}
					*/
					for k := uint32(1); k <= 2*p.F+1; k++ {
						vjki.SetBytes(currentData.Fk[k-1])
						wjk.SetCompressedBytes(currentData.Wk[k-1])

						//if j == 3 {
						//	fmt.Println("Party", p.PID, "receive w", p.PID+1, k, "=", w_j_k.String(), "from Party", j-1)
						//}
						//fmt.Println("Party", p.PID, vjki, w_j_k.String())
						//fmt.Println("Party ", p.PID, "can enter here")
						//fmt.Println("Party ", p.PID, "Verify v ", j, k, "result = ", KZG.VerifyEval(CQ[j][k], gmp.NewInt(int64(p.PID+1)), vjki, w_j_k))

						if KZG.VerifyEval(CQ[j][k], gmp.NewInt(int64(p.PID+1)), vjki, wjk) == false {
							VoteRevertFlag = true
							break
						}
					}
					if VoteRevertFlag == true {
						delete(ReshareDataMap, j) // discard this message
						continue
					}
					//Sig_hash := sha256.Sum256([]byte(string(j)))
					//Sig[j][int(p.PID+1)] = bls.Sign(Sig_hash, p.SigSK)
					Sig[j][p.PID+1], _ = tbls.Sign(SysSuite, p.SigSK, []byte(strconv.FormatUint(uint64(j), 10)))
					lambda := make([]*gmp.Int, 2*p.F+1)
					knownIndexes := make([]*gmp.Int, 2*p.F+1)
					for k := 0; uint32(k) < 2*p.F+1; k++ {
						knownIndexes[k] = gmp.NewInt(int64(k + 1))
						lambda[k] = gmp.NewInt(int64(k + 1))
					}
					for l := uint32(1); l <= p.N; l++ {
						polyring.GetLagrangeCoefficients(2*p.F, knownIndexes, ecparamN, gmp.NewInt(int64(l)), lambda)
						vF[j][l][p.PID+1].SetInt64(int64(0)) // might have a bug
						wF[j][l][p.PID+1].Set1()             // might have a bug
						for k := uint32(1); k <= 2*p.F+1; k++ {
							vjki.SetBytes(currentData.Fk[k-1])
							wjk.SetCompressedBytes(currentData.Wk[k-1])
							var copyFijl *gmp.Int
							var copyWijl *pbc.Element
							var tt1 *gmp.Int     // temp mul result
							var tt2 *pbc.Element // temp pow result
							tt1 = gmp.NewInt(0)
							tt2 = KZG.NewG1()
							copyFijl = gmp.NewInt(0)
							copyWijl = KZG.NewG1()
							copyFijl.Set(vF[j][l][p.PID+1])
							copyWijl.Set(wF[j][l][p.PID+1])
							tt1.Mul(lambda[k-1], vjki)
							vF[j][l][p.PID+1].Add(copyFijl, tt1)
							tt2.PowBig(wjk, conv.GmpInt2BigInt(lambda[k-1]))
							wF[j][l][p.PID+1].Mul(copyWijl, tt2)
						}
						// send Recover
						var RecoverMessage protobuf.Recover
						RecoverMessage.J = j
						RecoverMessage.V = vF[j][l][p.PID+1].Bytes()
						RecoverMessage.W = wF[j][l][p.PID+1].CompressedBytes()
						RecoverMessage.Sig = Sig[j][p.PID+1]
						RecoverMessageData, _ := proto.Marshal(&RecoverMessage)
						p.Send(&protobuf.Message{Type: "Recover", Id: ID, Sender: p.PID, Data: RecoverMessageData}, uint32(l-1))
					}
					delete(ReshareDataMap, j) //added
				}
			}
			mutexReshareDataMap.Unlock()
		}
	}()

	//Recover
	var RecoverDataMap = make(map[uint32]map[uint32]protobuf.Recover)
	for i := uint32(1); i <= p.N; i++ {
		RecoverDataMap[i] = make(map[uint32]protobuf.Recover)
	}
	var RecoverDataMapMutex sync.Mutex
	var SRec = make([][]SRecElement, p.N+1) // start from 1
	var SSig = make([][]SSigElement, p.N+1) // start from 1
	for i := uint32(0); i <= p.N; i++ {
		SRec[i] = make([]SRecElement, 0)
		SSig[i] = make([]SSigElement, 0)
	}
	var InterpolatePolyX = make([]*gmp.Int, p.N+1)
	var InterpolatePolyY = make([]*gmp.Int, p.N+1)
	var CombinedSig = make([][]byte, p.N+1) // start from 1
	var CombinedFlag = make([]bool, p.N+1)  //start from 1
	var MVBAIn = new(protobuf.MVBA_IN)
	MVBAIn.J = make([]uint32, 0)
	MVBAIn.Sig = make([][]byte, 0)
	var mutexMVBAIn sync.Mutex
	for i := uint32(0); i <= p.N; i++ {
		CombinedFlag[i] = false
	}
	var MVBASent = false
	MVBAResChan := make(chan []byte, 1)

	go func() {
		for {
			m := <-p.GetMessage("Recover", ID)
			var ReceivedRecoverData protobuf.Recover
			proto.Unmarshal(m.Data, &ReceivedRecoverData)
			RecoverDataMapMutex.Lock()
			_, ok := RecoverDataMap[ReceivedRecoverData.J][m.Sender+1]
			if !ok {
				RecoverDataMap[ReceivedRecoverData.J][m.Sender+1] = ReceivedRecoverData
			}
			RecoverDataMapMutex.Unlock()
		}
	}()

	go func() {
		for {
			RecoverDataMapMutex.Lock()
			for k := uint32(1); k <= p.N; k++ {
				for j := uint32(1); j <= p.N; j++ {
					_, ok := RecoverDataMap[k][j]
					if ok {
						currentRecoverData := RecoverDataMap[k][j]
						if flgCom[k] == 0 {
							continue //FIXME: wrong continue
						}

						var wkij *pbc.Element
						var vkij *gmp.Int
						vkij = gmp.NewInt(0)
						wkij = KZG.NewG1()
						vkij.SetBytes(currentRecoverData.V)
						wkij.SetCompressedBytes(currentRecoverData.W)

						ReceivedSig := currentRecoverData.Sig
						//Check_Sig_Hash := sha256.Sum256([]byte(string(j)))

						if !KZG.VerifyEval(CQ[k][p.PID+1], gmp.NewInt(int64(j)), vkij, wkij) || (tbls.Verify(SysSuite, p.SigPK, []byte(strconv.FormatUint(uint64(k), 10)), ReceivedSig) != nil) {
							delete(RecoverDataMap[k], j) // discard this message
							continue                     // ch change break to continue.
						}
						SRec[k] = append(SRec[k], SRecElement{j, vkij})
						if uint32(len(SRec[k])) >= p.F+1 && flgRec[k] == 0 {
							for t := 0; t < len(SRec[k]); t++ {
								InterpolatePolyX[t] = gmp.NewInt(int64(SRec[k][t].j))
								InterpolatePolyY[t] = SRec[k][t].v
							}

							Q[k][p.PID+1], _ = interpolation.LagrangeInterpolate(int(p.F), InterpolatePolyX[:p.F+1], InterpolatePolyY[:p.F+1], ecparamN) //ch add :p.F+1
							flgRec[k] = 1
						}
						SSig[k] = append(SSig[k], SSigElement{j, ReceivedSig})
						if uint32(len(SSig[k])) >= 2*p.F+1 && !CombinedFlag[k] {
							var tmpSig = make([][]byte, len(SSig))
							for t := 0; t < len(SSig[k]); t++ {
								tmpSig[t] = SSig[k][t].Sig
							}
							//converting uint32 to int is dangerous
							CombinedSig[k], _ = tbls.Recover(SysSuite, p.SigPK, []byte(strconv.FormatUint(uint64(k), 10)), tmpSig, int(2*p.F), int(p.N))
							CombinedFlag[k] = true
							mutexMVBAIn.Lock()
							MVBAIn.J = append(MVBAIn.J, k)
							MVBAIn.Sig = append(MVBAIn.Sig, CombinedSig[k])
							if uint32(len(MVBAIn.J)) >= p.N-p.F && MVBASent == false {
								fmt.Println("Party", p.PID, "calls MVBA")
								MVBAInData, _ := proto.Marshal(MVBAIn)
								MVBAResChan <- MainProcess(p, ID, MVBAInData, []byte{}) //temporary solution (MainProcess means smvba.MainProcess)
								MVBASent = true
							}
							mutexMVBAIn.Unlock()
						}
						delete(RecoverDataMap[k], j) // added by ch
					}
				}
			}
			RecoverDataMapMutex.Unlock()
		}
	}()

	//MVBA
	//TODO:implement MVBA's verification
	MVBAResData := <-MVBAResChan //question: do we need waitGroup to synchronize the MVBA instances?
	var MVBARes protobuf.MVBA_IN
	proto.Unmarshal(MVBAResData, &MVBARes)
	fmt.Println("Party", p.PID, " output MBVA result:", MVBARes.J)

	//Refresh
	var CQsum = make([]*pbc.Element, p.N+1)
	var Qsum = polyring.NewEmpty()

	for i := uint32(0); i <= p.N; i++ {
		CQsum[i] = KZG.NewG1()
	}
	for {

		for i := 0; uint32(i) < p.N-p.F; i++ {
			if flgCom[MVBARes.J[i]] == 0 {
				continue //FIXME: wrong continue
			}
		}

		for i := 0; uint32(i) < p.N-p.F; i++ {
			copyedQ := polyring.NewEmpty()
			copyedQ.ResetTo(Qsum)
			//fmt.Println("Party ", p.PID, "Q[MVBARes.J[i]][p.PID+1] =")
			//Q[MVBARes.J[i]][p.PID+1].Print()
			Qsum.Add(copyedQ, Q[MVBARes.J[i]][p.PID+1])
			Qsum.Mod(ecparamN)
		}
		//TODO: add CQsum here later!!
		fmt.Println("Party", p.PID, "recover Qsum:")
		Qsum.Print()
		fmt.Println("Party", p.PID, "previous reducedShare:")
		p.reducedShare.Print()
		copyed_halfShare := polyring.NewEmpty()
		copyed_halfShare.ResetTo(p.reducedShare)
		p.reducedShare.Add(Qsum, copyed_halfShare)
		p.reducedShare.Mod(ecparamN)
		fmt.Println("Party ", p.PID, "get its new reducedShare:")
		p.reducedShare.Print()
		break
	}

	//-------------------------------------ShareDist-------------------------------------
	//Init
	var SCom = make(map[uint32]SComElement)
	var SB []SBElement = make([]SBElement, 0)
	var SComMutex sync.Mutex

	//Commit
	var CB = make([]*pbc.Element, p.N+1)
	for i := uint32(0); i <= p.N; i++ {
		CB[i] = KZG.NewG1()
	}

	KZG.Commit(CB[p.PID+1], p.reducedShare)
	var NewcommitMessage protobuf.NewCommit
	NewcommitMessage.CB = CB[p.PID+1].CompressedBytes()
	NewcommitMessageData, _ := proto.Marshal(&NewcommitMessage)
	p.RBCSend(&protobuf.Message{Type: "NewCommit", Id: ID, Sender: p.PID, Data: NewcommitMessageData}, []byte(string(ID)+"Distribute"+strconv.FormatUint(uint64(p.PID+1), 10))) // this ID is not correct

	//Distribute
	var wBij *pbc.Element
	var Bij *gmp.Int
	wBij = KZG.NewG1()
	Bij = gmp.NewInt(0)

	for j := uint32(1); j <= p.N; j++ {
		p.reducedShare.EvalMod(gmp.NewInt(int64(j)), ecparamN, Bij)
		KZG.CreateWitness(wBij, p.reducedShare, gmp.NewInt(int64(j)))
		var ShareDistMessage protobuf.ShareDist
		ShareDistMessage.B = Bij.Bytes()
		ShareDistMessage.WB = wBij.CompressedBytes()
		SharedistMessageData, _ := proto.Marshal(&ShareDistMessage)
		p.Send(&protobuf.Message{Type: "ShareDist", Id: ID, Sender: p.PID, Data: SharedistMessageData}, uint32(j-1))
	}

	//Verify
	for j := uint32(1); j <= p.N; j++ {
		go func(j uint32) {
			m := p.RBCReceive([]byte(string(ID) + "Distribute" + strconv.FormatUint(uint64(j), 10)))
			NewCommitData := m.Data
			var ReceivedCB *pbc.Element
			ReceivedCB = KZG.NewG1()
			ReceivedCB.SetCompressedBytes(NewCommitData)

			SComMutex.Lock()
			SCom[m.Sender+1] = SComElement{
				j:  m.Sender + 1,
				CB: KZG.NewG1(),
			}
			SCom[m.Sender+1].CB.Set(ReceivedCB) //here add it without Verifying temporarily  //ch change j to m.sender+1
			//TODO: Add Verification here (CB'(x,j) == CB(x,j)CQsum(x,j) ?)
			SComMutex.Unlock()
		}(j)
	}

	//Interpolate
	var ShareDistMap = make(map[uint32]protobuf.ShareDist)
	var mutexShareDistMap sync.Mutex
	var ReceivedShareDistData protobuf.ShareDist
	var SuccessSent = false
	var SuccessSentChan = make(chan bool, 1)

	go func() {
		for {
			m := <-p.GetMessage("ShareDist", ID) // this ID is not correct
			proto.Unmarshal(m.Data, &ReceivedShareDistData)
			mutexShareDistMap.Lock()
			_, ok := ShareDistMap[m.Sender+1]
			if !ok {
				ShareDistMap[m.Sender+1] = ReceivedShareDistData
			}
			mutexShareDistMap.Unlock()
		}
	}()
	go func() {
		for {
			for j := uint32(1); j <= p.N; j++ {
				mutexShareDistMap.Lock()
				_, ok := ShareDistMap[j]
				if ok == true {
					SComMutex.Lock()
					_, ok2 := SCom[j]
					if ok2 == true {
						currentSharedistData := ShareDistMap[j]
						currentCB := SCom[j].CB
						var vjShareDist *gmp.Int
						var wjShareDist *pbc.Element
						vjShareDist = gmp.NewInt(0)
						wjShareDist = KZG.NewG1()
						vjShareDist.SetBytes(currentSharedistData.B)
						wjShareDist.SetCompressedBytes(currentSharedistData.WB)
						//fmt.Println(KZG.VerifyEval(currentCB, gmp.NewInt(int64(p.PID+1)), vjShareDist, wjShareDist))
						/*
							if KZG.VerifyEval(currentCB, gmp.NewInt(int64(p.PID+1)), vjShareDist, wjShareDist) == false {
								delete(ShareDistMap, j)
								mutexShareDistMap.Unlock()
								S_com_Mutex.Unlock()
								continue
							}*/
						// debug for KZG Verification later.
						// TODO: complete the KZG verification here.
						SB = append(SB, SBElement{
							j:  0,
							CB: KZG.NewG1(),
							v:  gmp.NewInt(0),
							w:  KZG.NewG1(),
						})
						length := len(SB)
						SB[length-1].j = j
						SB[length-1].CB.Set(currentCB)
						SB[length-1].v.Set(vjShareDist)
						SB[length-1].w.Set(wjShareDist)

						if uint32(len(SB)) >= 2*p.F+1 && SuccessSent == false { //ch added "&&SuccessSent == false"
							var DistX []*gmp.Int = make([]*gmp.Int, 2*p.F+1)
							var DistY []*gmp.Int = make([]*gmp.Int, 2*p.F+1)
							for t := uint32(0); t < 2*p.F+1; t++ {
								DistX[t] = gmp.NewInt(int64(SB[t].j))
								DistY[t] = gmp.NewInt(0)
								DistY[t].Set(SB[t].v)
							}
							p.fullShare, _ = interpolation.LagrangeInterpolate(int(2*p.F), DistX, DistY, ecparamN)
							fmt.Println("Party ", p.PID, "recover full Share:")
							p.fullShare.Print()
							var SuccessMessage protobuf.Success
							SuccessMessage.Nothing = []byte("123") // doesn't matter. Send whatever you want
							SuccessData, _ := proto.Marshal(&SuccessMessage)
							p.Broadcast(&protobuf.Message{Type: "Success", Id: ID, Sender: p.PID, Data: SuccessData})
							SuccessSent = true      //added by ch
							SuccessSentChan <- true //added by ch
						}
						delete(ShareDistMap, j) // added by ch
					}
					SComMutex.Unlock()

				}
				mutexShareDistMap.Unlock()
			}
		}

	}()

	// Receive Success Message
	var SuccessMap = make(map[uint32]protobuf.Success)
	var mutexSuccessMap sync.Mutex
	var ReceivedSuccessData protobuf.Success
	var SuccessCount = uint32(0)

	go func() {
		<-SuccessSentChan //added by ch
		for {
			m := <-p.GetMessage("Success", ID) // this ID is not correct //ch thinks it is correct
			proto.Unmarshal(m.Data, &ReceivedSuccessData)
			mutexSuccessMap.Lock()
			_, ok := SuccessMap[m.Sender+1]
			if !ok {
				SuccessMap[m.Sender+1] = ReceivedSuccessData
				SuccessCount++
			}
			if SuccessCount >= 2*p.F+1 {
				mutexSuccessMap.Unlock()
				fmt.Println("Party ", p.PID, "Enter the normal state")
				break // Enter normal state
			}
			mutexSuccessMap.Unlock()
		}

	}()
}
